#include "../wp.h"
#include "op.h"

const char* const IROpNames[Op_MAX] = {
  // Do not edit. Generated by misc/gen_ops.py
  "Nil",
  "Phi",
  "ConstBool",
  "ConstI8",
  "ConstI16",
  "ConstI32",
  "ConstI64",
  "ConstF32",
  "ConstF64",
  "AddI8",
  "AddI16",
  "AddI32",
  "AddI64",
  "AddF32",
  "AddF64",
  "SubI8",
  "SubI16",
  "SubI32",
  "SubI64",
  "SubF32",
  "SubF64",
  "MulI8",
  "MulI16",
  "MulI32",
  "MulI64",
  "MulF32",
  "MulF64",
  "DivS8",
  "DivU8",
  "DivS16",
  "DivU16",
  "DivS32",
  "DivU32",
  "DivS64",
  "DivU64",
  "DivF32",
  "DivF64",
  "EqB",
  "EqI8",
  "EqI16",
  "EqI32",
  "EqI64",
  "EqF32",
  "EqF64",
  "NEqB",
  "NEqI8",
  "NEqI16",
  "NEqI32",
  "NEqI64",
  "NEqF32",
  "NEqF64",
  "LessS8",
  "LessU8",
  "LessS16",
  "LessU16",
  "LessS32",
  "LessU32",
  "LessS64",
  "LessU64",
  "LessF32",
  "LessF64",
  "GreaterS8",
  "GreaterU8",
  "GreaterS16",
  "GreaterU16",
  "GreaterS32",
  "GreaterU32",
  "GreaterS64",
  "GreaterU64",
  "GreaterF32",
  "GreaterF64",
  "LEqS8",
  "LEqU8",
  "LEqS16",
  "LEqU16",
  "LEqS32",
  "LEqU32",
  "LEqS64",
  "LEqU64",
  "LEqF32",
  "LEqF64",
  "GEqS8",
  "GEqU8",
  "GEqS16",
  "GEqU16",
  "GEqS32",
  "GEqU32",
  "GEqS64",
  "GEqU64",
  "GEqF32",
  "GEqF64",
  "AndB",
  "OrB",
  "NotB",
  "NegI8",
  "NegI16",
  "NegI32",
  "NegI64",
  "NegF32",
  "NegF64",
};


// _IROpConstMap maps TypeCode => IROp for constant materialization
const IROp _IROpConstMap[TypeCode_INTRINSIC_NUM_END] = {
  // Do not edit. Generated by misc/gen_ops.py
  /* TypeCode_bool    = */ OpConstBool,
  /* TypeCode_int8    = */ OpConstI8,
  /* TypeCode_uint8   = */ OpConstI8,
  /* TypeCode_int16   = */ OpConstI16,
  /* TypeCode_uint16  = */ OpConstI16,
  /* TypeCode_int32   = */ OpConstI32,
  /* TypeCode_uint32  = */ OpConstI32,
  /* TypeCode_int64   = */ OpConstI64,
  /* TypeCode_uint64  = */ OpConstI64,
  /* TypeCode_float32 = */ OpConstF32,
  /* TypeCode_float64 = */ OpConstF64,
};


const IROpDescr _IROpInfoMap[Op_MAX] = {
  0
};


IROp IROpFromAST(Tok tok, TypeCode type1, TypeCode type2) {
  assert(tok > T_OPS_START);  // op must be an operator token
  assert(tok < T_OPS_END);
  assert(type1 < TypeCode_INTRINSIC_NUM_END); // t must be a concrete, basic numeric type
  assert(type2 == TypeCode_nil || type2 < TypeCode_INTRINSIC_NUM_END);
  //!BEGIN_AST_TO_IR_OP_SWITCHES
  // Do not edit. Generated by misc/gen_ops.py
  switch (type1) {
    case TypeCode_bool:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TBang : return OpNotB ;// bool -> bool
          default: return OpNil;
        }
        case TypeCode_bool: switch (tok) {
          case TEqEq : return OpEqB  ;// bool bool -> bool
          case TNEq  : return OpNEqB ;// bool bool -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    case TypeCode_int8:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TMinus : return OpNegI8 ;// i8 -> i8
          default: return OpNil;
        }
        case TypeCode_int8: switch (tok) {
          case TSlash : return OpDivS8     ;// s8 s8 -> s8
          case TGt    : return OpGreaterS8 ;// s8 s8 -> bool
          case TLt    : return OpLessS8    ;// s8 s8 -> bool
          case TLEq   : return OpLEqS8     ;// s8 s8 -> bool
          case TGEq   : return OpGEqS8     ;// s8 s8 -> bool
          case TPlus  : return OpAddI8     ;// i8 i8 -> i8
          case TMinus : return OpSubI8     ;// i8 i8 -> i8
          case TStar  : return OpMulI8     ;// i8 i8 -> i8
          case TEqEq  : return OpEqI8      ;// i8 i8 -> bool
          case TNEq   : return OpNEqI8     ;// i8 i8 -> bool
          default: return OpNil;
        }
        case TypeCode_uint8: switch (tok) {
          case TPlus  : return OpAddI8 ;// i8 i8 -> i8
          case TMinus : return OpSubI8 ;// i8 i8 -> i8
          case TStar  : return OpMulI8 ;// i8 i8 -> i8
          case TEqEq  : return OpEqI8  ;// i8 i8 -> bool
          case TNEq   : return OpNEqI8 ;// i8 i8 -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    case TypeCode_uint8:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TMinus : return OpNegI8 ;// i8 -> i8
          default: return OpNil;
        }
        case TypeCode_int8: switch (tok) {
          case TPlus  : return OpAddI8 ;// i8 i8 -> i8
          case TMinus : return OpSubI8 ;// i8 i8 -> i8
          case TStar  : return OpMulI8 ;// i8 i8 -> i8
          case TEqEq  : return OpEqI8  ;// i8 i8 -> bool
          case TNEq   : return OpNEqI8 ;// i8 i8 -> bool
          default: return OpNil;
        }
        case TypeCode_uint8: switch (tok) {
          case TSlash : return OpDivU8     ;// u8 u8 -> u8
          case TGt    : return OpGreaterU8 ;// u8 u8 -> bool
          case TLt    : return OpLessU8    ;// u8 u8 -> bool
          case TLEq   : return OpLEqU8     ;// u8 u8 -> bool
          case TGEq   : return OpGEqU8     ;// u8 u8 -> bool
          case TPlus  : return OpAddI8     ;// i8 i8 -> i8
          case TMinus : return OpSubI8     ;// i8 i8 -> i8
          case TStar  : return OpMulI8     ;// i8 i8 -> i8
          case TEqEq  : return OpEqI8      ;// i8 i8 -> bool
          case TNEq   : return OpNEqI8     ;// i8 i8 -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    case TypeCode_int16:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TMinus : return OpNegI16 ;// i16 -> i16
          default: return OpNil;
        }
        case TypeCode_int16: switch (tok) {
          case TSlash : return OpDivS16     ;// s16 s16 -> s16
          case TGt    : return OpGreaterS16 ;// s16 s16 -> bool
          case TLt    : return OpLessS16    ;// s16 s16 -> bool
          case TLEq   : return OpLEqS16     ;// s16 s16 -> bool
          case TGEq   : return OpGEqS16     ;// s16 s16 -> bool
          case TPlus  : return OpAddI16     ;// i16 i16 -> i16
          case TMinus : return OpSubI16     ;// i16 i16 -> i16
          case TStar  : return OpMulI16     ;// i16 i16 -> i16
          case TEqEq  : return OpEqI16      ;// i16 i16 -> bool
          case TNEq   : return OpNEqI16     ;// i16 i16 -> bool
          default: return OpNil;
        }
        case TypeCode_uint16: switch (tok) {
          case TPlus  : return OpAddI16 ;// i16 i16 -> i16
          case TMinus : return OpSubI16 ;// i16 i16 -> i16
          case TStar  : return OpMulI16 ;// i16 i16 -> i16
          case TEqEq  : return OpEqI16  ;// i16 i16 -> bool
          case TNEq   : return OpNEqI16 ;// i16 i16 -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    case TypeCode_uint16:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TMinus : return OpNegI16 ;// i16 -> i16
          default: return OpNil;
        }
        case TypeCode_int16: switch (tok) {
          case TPlus  : return OpAddI16 ;// i16 i16 -> i16
          case TMinus : return OpSubI16 ;// i16 i16 -> i16
          case TStar  : return OpMulI16 ;// i16 i16 -> i16
          case TEqEq  : return OpEqI16  ;// i16 i16 -> bool
          case TNEq   : return OpNEqI16 ;// i16 i16 -> bool
          default: return OpNil;
        }
        case TypeCode_uint16: switch (tok) {
          case TSlash : return OpDivU16     ;// u16 u16 -> u16
          case TGt    : return OpGreaterU16 ;// u16 u16 -> bool
          case TLt    : return OpLessU16    ;// u16 u16 -> bool
          case TLEq   : return OpLEqU16     ;// u16 u16 -> bool
          case TGEq   : return OpGEqU16     ;// u16 u16 -> bool
          case TPlus  : return OpAddI16     ;// i16 i16 -> i16
          case TMinus : return OpSubI16     ;// i16 i16 -> i16
          case TStar  : return OpMulI16     ;// i16 i16 -> i16
          case TEqEq  : return OpEqI16      ;// i16 i16 -> bool
          case TNEq   : return OpNEqI16     ;// i16 i16 -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    case TypeCode_int32:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TMinus : return OpNegI32 ;// i32 -> i32
          default: return OpNil;
        }
        case TypeCode_int32: switch (tok) {
          case TSlash : return OpDivS32     ;// s32 s32 -> s32
          case TGt    : return OpGreaterS32 ;// s32 s32 -> bool
          case TLt    : return OpLessS32    ;// s32 s32 -> bool
          case TLEq   : return OpLEqS32     ;// s32 s32 -> bool
          case TGEq   : return OpGEqS32     ;// s32 s32 -> bool
          case TPlus  : return OpAddI32     ;// i32 i32 -> i32
          case TMinus : return OpSubI32     ;// i32 i32 -> i32
          case TStar  : return OpMulI32     ;// i32 i32 -> i32
          case TEqEq  : return OpEqI32      ;// i32 i32 -> bool
          case TNEq   : return OpNEqI32     ;// i32 i32 -> bool
          default: return OpNil;
        }
        case TypeCode_uint32: switch (tok) {
          case TPlus  : return OpAddI32 ;// i32 i32 -> i32
          case TMinus : return OpSubI32 ;// i32 i32 -> i32
          case TStar  : return OpMulI32 ;// i32 i32 -> i32
          case TEqEq  : return OpEqI32  ;// i32 i32 -> bool
          case TNEq   : return OpNEqI32 ;// i32 i32 -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    case TypeCode_uint32:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TMinus : return OpNegI32 ;// i32 -> i32
          default: return OpNil;
        }
        case TypeCode_int32: switch (tok) {
          case TPlus  : return OpAddI32 ;// i32 i32 -> i32
          case TMinus : return OpSubI32 ;// i32 i32 -> i32
          case TStar  : return OpMulI32 ;// i32 i32 -> i32
          case TEqEq  : return OpEqI32  ;// i32 i32 -> bool
          case TNEq   : return OpNEqI32 ;// i32 i32 -> bool
          default: return OpNil;
        }
        case TypeCode_uint32: switch (tok) {
          case TSlash : return OpDivU32     ;// u32 u32 -> u32
          case TGt    : return OpGreaterU32 ;// u32 u32 -> bool
          case TLt    : return OpLessU32    ;// u32 u32 -> bool
          case TLEq   : return OpLEqU32     ;// u32 u32 -> bool
          case TGEq   : return OpGEqU32     ;// u32 u32 -> bool
          case TPlus  : return OpAddI32     ;// i32 i32 -> i32
          case TMinus : return OpSubI32     ;// i32 i32 -> i32
          case TStar  : return OpMulI32     ;// i32 i32 -> i32
          case TEqEq  : return OpEqI32      ;// i32 i32 -> bool
          case TNEq   : return OpNEqI32     ;// i32 i32 -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    case TypeCode_int64:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TMinus : return OpNegI64 ;// i64 -> i64
          default: return OpNil;
        }
        case TypeCode_int64: switch (tok) {
          case TSlash : return OpDivS64     ;// s64 s64 -> s64
          case TGt    : return OpGreaterS64 ;// s64 s64 -> bool
          case TLt    : return OpLessS64    ;// s64 s64 -> bool
          case TLEq   : return OpLEqS64     ;// s64 s64 -> bool
          case TGEq   : return OpGEqS64     ;// s64 s64 -> bool
          case TPlus  : return OpAddI64     ;// i64 i64 -> i64
          case TMinus : return OpSubI64     ;// i64 i64 -> i64
          case TStar  : return OpMulI64     ;// i64 i64 -> i64
          case TEqEq  : return OpEqI64      ;// i64 i64 -> bool
          case TNEq   : return OpNEqI64     ;// i64 i64 -> bool
          default: return OpNil;
        }
        case TypeCode_uint64: switch (tok) {
          case TPlus  : return OpAddI64 ;// i64 i64 -> i64
          case TMinus : return OpSubI64 ;// i64 i64 -> i64
          case TStar  : return OpMulI64 ;// i64 i64 -> i64
          case TEqEq  : return OpEqI64  ;// i64 i64 -> bool
          case TNEq   : return OpNEqI64 ;// i64 i64 -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    case TypeCode_uint64:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TMinus : return OpNegI64 ;// i64 -> i64
          default: return OpNil;
        }
        case TypeCode_int64: switch (tok) {
          case TPlus  : return OpAddI64 ;// i64 i64 -> i64
          case TMinus : return OpSubI64 ;// i64 i64 -> i64
          case TStar  : return OpMulI64 ;// i64 i64 -> i64
          case TEqEq  : return OpEqI64  ;// i64 i64 -> bool
          case TNEq   : return OpNEqI64 ;// i64 i64 -> bool
          default: return OpNil;
        }
        case TypeCode_uint64: switch (tok) {
          case TSlash : return OpDivU64     ;// u64 u64 -> u64
          case TGt    : return OpGreaterU64 ;// u64 u64 -> bool
          case TLt    : return OpLessU64    ;// u64 u64 -> bool
          case TLEq   : return OpLEqU64     ;// u64 u64 -> bool
          case TGEq   : return OpGEqU64     ;// u64 u64 -> bool
          case TPlus  : return OpAddI64     ;// i64 i64 -> i64
          case TMinus : return OpSubI64     ;// i64 i64 -> i64
          case TStar  : return OpMulI64     ;// i64 i64 -> i64
          case TEqEq  : return OpEqI64      ;// i64 i64 -> bool
          case TNEq   : return OpNEqI64     ;// i64 i64 -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    case TypeCode_float32:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TMinus : return OpNegF32 ;// f32 -> f32
          default: return OpNil;
        }
        case TypeCode_float32: switch (tok) {
          case TPlus  : return OpAddF32     ;// f32 f32 -> f32
          case TMinus : return OpSubF32     ;// f32 f32 -> f32
          case TStar  : return OpMulF32     ;// f32 f32 -> f32
          case TSlash : return OpDivF32     ;// f32 f32 -> f32
          case TGt    : return OpGreaterF32 ;// f32 f32 -> bool
          case TLt    : return OpLessF32    ;// f32 f32 -> bool
          case TEqEq  : return OpEqF32      ;// f32 f32 -> bool
          case TNEq   : return OpNEqF32     ;// f32 f32 -> bool
          case TLEq   : return OpLEqF32     ;// f32 f32 -> bool
          case TGEq   : return OpGEqF32     ;// f32 f32 -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    case TypeCode_float64:
      switch (type2) {
        case TypeCode_nil: switch (tok) {
          case TMinus : return OpNegF64 ;// f64 -> f64
          default: return OpNil;
        }
        case TypeCode_float64: switch (tok) {
          case TPlus  : return OpAddF64     ;// f64 f64 -> f64
          case TMinus : return OpSubF64     ;// f64 f64 -> f64
          case TStar  : return OpMulF64     ;// f64 f64 -> f64
          case TSlash : return OpDivF64     ;// f64 f64 -> f64
          case TGt    : return OpGreaterF64 ;// f64 f64 -> bool
          case TLt    : return OpLessF64    ;// f64 f64 -> bool
          case TEqEq  : return OpEqF64      ;// f64 f64 -> bool
          case TNEq   : return OpNEqF64     ;// f64 f64 -> bool
          case TLEq   : return OpLEqF64     ;// f64 f64 -> bool
          case TGEq   : return OpGEqF64     ;// f64 f64 -> bool
          default: return OpNil;
        }
        default: return OpNil;
      } // switch (type2)
    default: return OpNil;
  } // switch (type1)
    //!END_AST_TO_IR_OP_SWITCHES
}



W_UNIT_TEST(IROp, {
  printf("--------------------------------------------------\n");
  FWAllocator mem = {0};
  FWAllocInit(&mem);
  #define mknode(t) NewNode(&mem, (t))

  TypeCode type1 = TypeCode_int32;
  TypeCode type2 = TypeCode_int16;
  dlog("type1: 0x%X", type1);
  dlog("type2: 0x%X", type2);
  u32 key = ((u32)type1 << 16) | (u32)type2;
  dlog("key: 0x%X", key);
  dlog("t1 0x%X", key >> 16);
  dlog("t2 0x%X", key & 0xFFFF);

  // TODO: rewrite these tests to use the new matrix table:
  //
  // // construct an AST node: uint32:(Op +)
  // auto uint32TypeNode = mknode(NBasicType);
  // uint32TypeNode->t.basic.typeCode = TypeCode_uint32;
  //
  // auto addUInt32OpNode = mknode(NOp);
  // addUInt32OpNode->op.op = TPlus;
  // addUInt32OpNode->type = uint32TypeNode;
  //
  // auto n = addUInt32OpNode;
  //
  // int index1 = n->op.op - T_OPS_START - 1;
  // dlog("index1: %d", index1);
  //
  // auto irOpTable = astToIROpTable[index1];
  // // dlog("astToIROpTable_Add: %p", astToIROpTable_Add);
  // // dlog("astToIROpTable_Sub: %p", astToIROpTable_Sub);
  // // dlog("astToIROpTable_Mul: %p", astToIROpTable_Mul);
  // // dlog("astToIROpTable_Div: %p", astToIROpTable_Div);
  // // dlog("matched irOpTable:  %p", irOpTable);
  // assert(irOpTable != NULL);
  //
  // auto irop = irOpTable[n->type->t.basic.typeCode];
  // dlog("irop: TypeCode %c #%d => #%u %s",
  //   TypeCodeEncoding[n->type->t.basic.typeCode], n->type->t.basic.typeCode,
  //   irop, IROpNames[irop]);
  // assert(irop == OpAddI32);
  //
  // assert(IROpFromASTOp2(n->op.op, n->type->t.basic.typeCode, n->type->t.basic.typeCode)
  //        == OpAddI32);

  // IROp IROpFromAST(Tok tok, TypeCode type1, TypeCode type2)

  assert(IROpFromAST(TMinus, TypeCode_int32, TypeCode_nil) == OpNegI32);

  assert(IROpFromAST(TPlus, TypeCode_int8, TypeCode_int8) == OpAddI8);
  assert(IROpFromAST(TPlus, TypeCode_uint8, TypeCode_uint8) == OpAddI8);
  assert(IROpFromAST(TPlus, TypeCode_int16, TypeCode_int16) == OpAddI16);
  assert(IROpFromAST(TPlus, TypeCode_uint16, TypeCode_uint16) == OpAddI16);
  assert(IROpFromAST(TPlus, TypeCode_int32, TypeCode_int32) == OpAddI32);
  assert(IROpFromAST(TPlus, TypeCode_uint32, TypeCode_uint32) == OpAddI32);
  assert(IROpFromAST(TPlus, TypeCode_int64, TypeCode_int64) == OpAddI64);
  assert(IROpFromAST(TPlus, TypeCode_uint64, TypeCode_uint64) == OpAddI64);


  FWAllocFree(&mem);
  printf("--------------------------------------------------\n");
}) // W_UNIT_TEST
