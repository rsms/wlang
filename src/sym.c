//
// sym is a string type that is interned and can be efficiently compared
// for equality by pointer value. It's used for identifiers.
//
#include "wp.h"
#include "sym.h"

#define RBKEY Sym
#include "rbtree.c"

static Sym newsym(u32 hash, const u8* ptr, size_t len, u8 flags);

// predefined common identifiers
#define PREDEFINED_IDENTS(SYMDEF) \
  SYMDEF( _   ) \
  SYMDEF( int ) \
/*END PREDEFINED_IDENTS*/

// -----------------------------------------------------------------------------------------
// generated by gen_constants at the end of this file.
// Define to 2 or 1 to run the generator during program initialization:
// #define W_SYM_RUN_GENERATOR 2

const Sym sym_break = "\0\0\0\0\0\0\0\x78\x81\x64\xC9\x05\x00\x05\x00\x0A""break" + 16;
const Sym sym_case = "\0\0\0\0\0\0\0\xB1\x38\x25\x9B\x04\x00\x04\x00\x12""case" + 16;
const Sym sym_const = "\0\0\0\0\0\0\0\xD4\xD1\x4F\x66\x05\x00\x05\x00\x1A""const" + 16;
const Sym sym_continue = "\0\0\0\0\0\0\0\x44\x7E\x72\xB1\x08\x00\x08\x00\x22""continue" + 16;
const Sym sym_default = "\0\0\0\0\0\0\0\xDE\x5B\x3B\x93\x07\x00\x07\x00\x2A""default" + 16;
const Sym sym_defer = "\0\0\0\0\0\0\0\x3B\xFB\x01\x1A\x05\x00\x05\x00\x32""defer" + 16;
const Sym sym_else = "\0\0\0\0\0\0\0\xF0\x5B\xBF\xBD\x04\x00\x04\x00\x3A""else" + 16;
const Sym sym_enum = "\0\0\0\0\0\0\0\x00\xB0\x6C\x81\x04\x00\x04\x00\x42""enum" + 16;
const Sym sym_fallthrough = "\0\0\0\0\0\0\0\x09\x7B\x34\x80\x0B\x00\x0B\x00\x4A""fallthrough" + 16;
const Sym sym_for = "\0\0\0\0\0\0\0\x90\x83\xF3\xAC\x03\x00\x03\x00\x52""for" + 16;
const Sym sym_fun = "\0\0\0\0\0\0\0\x5E\x78\xDB\xA8\x03\x00\x03\x00\x5A""fun" + 16;
const Sym sym_go = "\0\0\0\0\0\0\0\x4B\x77\x20\x42\x02\x00\x02\x00\x62""go" + 16;
const Sym sym_if = "\0\0\0\0\0\0\0\x06\x6E\x38\x39\x02\x00\x02\x00\x6A""if" + 16;
const Sym sym_import = "\0\0\0\0\0\0\0\xD4\x90\x2A\x11\x06\x00\x06\x00\x72""import" + 16;
const Sym sym_in = "\0\0\0\0\0\0\0\x9E\x7A\x38\x41\x02\x00\x02\x00\x7A""in" + 16;
const Sym sym_interface = "\0\0\0\0\0\0\0\x30\x51\xEA\x84\x09\x00\x09\x00\x82""interface" + 16;
const Sym sym_is = "\0\0\0\0\0\0\0\x15\x8F\x38\x4E\x02\x00\x02\x00\x8A""is" + 16;
const Sym sym_return = "\0\0\0\0\0\0\0\xBF\x37\xEE\x85\x06\x00\x06\x00\x92""return" + 16;
const Sym sym_select = "\0\0\0\0\0\0\0\x2D\x66\xC2\x11\x06\x00\x06\x00\x9A""select" + 16;
const Sym sym_struct = "\0\0\0\0\0\0\0\x20\xBE\xC2\x92\x06\x00\x06\x00\xA2""struct" + 16;
const Sym sym_switch = "\0\0\0\0\0\0\0\x71\x5F\xE0\x93\x06\x00\x06\x00\xAA""switch" + 16;
const Sym sym_symbol = "\0\0\0\0\0\0\0\xD1\x51\xFB\xF3\x06\x00\x06\x00\xB2""symbol" + 16;
const Sym sym_type = "\0\0\0\0\0\0\0\x4D\xF1\x27\x51\x04\x00\x04\x00\xBA""type" + 16;
const Sym sym_var = "\0\0\0\0\0\0\0\xBE\xE7\x25\x8A\x03\x00\x03\x00\xC2""var" + 16;
const Sym sym_while = "\0\0\0\0\0\0\0\xCE\x28\xC6\x0D\x05\x00\x05\x00\xCA""while" + 16;
const Sym sym__ = "\0\0\0\0\0\0\0\x6E\x19\x0C\xDA\x01\x00\x01\x00\x02""_" + 16;
const Sym sym_int = "\0\0\0\0\0\0\0\x5E\x7E\xE9\x95\x03\x00\x03\x00\x02""int" + 16;

static RBNode n_while = { sym_while, true, null, null };
static RBNode n_import = { sym_import, false, &n_while, null };
static RBNode n_defer = { sym_defer, false, null, null };
static RBNode n_select = { sym_select, true, &n_import, &n_defer };
static RBNode n_in = { sym_in, false, null, null };
static RBNode n_is = { sym_is, true, null, null };
static RBNode n_type = { sym_type, false, &n_is, null };
static RBNode n_go = { sym_go, true, &n_in, &n_type };
static RBNode n_if = { sym_if, false, &n_select, &n_go };
static RBNode n_fallthrough = { sym_fallthrough, false, null, null };
static RBNode n_interface = { sym_interface, false, null, null };
static RBNode n_enum = { sym_enum, false, &n_fallthrough, &n_interface };
static RBNode n_const = { sym_const, true, &n_if, &n_enum };
static RBNode n_var = { sym_var, true, null, null };
static RBNode n_struct = { sym_struct, false, &n_var, null };
static RBNode n_switch = { sym_switch, true, null, null };
static RBNode n_int = { sym_int, false, &n_switch, null };
static RBNode n_default = { sym_default, false, &n_struct, &n_int };
static RBNode n_fun = { sym_fun, true, null, null };
static RBNode n_continue = { sym_continue, true, null, null };
static RBNode n_for = { sym_for, false, &n_fun, &n_continue };
static RBNode n_break = { sym_break, true, null, null };
static RBNode n_symbol = { sym_symbol, true, null, null };
static RBNode n__ = { sym__, false, &n_break, &n_symbol };
static RBNode n_else = { sym_else, false, &n_for, &n__ };
static RBNode n_case = { sym_case, true, &n_default, &n_else };
static RBNode n_return = { sym_return, false, &n_const, &n_case };

static RBNode* symRoot = &n_return;
#ifndef NDEBUG
static const char* const debugKeywordsCheck =
  "break 1001 case 1002 const 1003 continue 1004 default 1005 defer 1006 else 1007 enum 1008 "
  "fallthrough 1009 for 100a fun 100b go 100c if 100d import 100e in 100f interface 1010 is 1011 "
  "return 1012 select 1013 struct 1014 switch 1015 symbol 1016 type 1017 var 1018 while 1019 "
  "";
#endif


// __attribute__((constructor)) static void init() {
//   // sym__ = newsym(3658226030, (const u8*)"_", 1, SDS_TYPE_16);
//   #define FLAGS(t) (SDS_TYPE_16 | ((t - TKeywordsStart) << SDS_TYPE_BITS))
//   n_break.key = newsym(3378807160, (const u8*)"break", 5, FLAGS(TBreak));
//   n_case.key = newsym(2602907825, (const u8*)"case", 4, FLAGS(TCase));
//   n_const.key = newsym(1716507092, (const u8*)"const", 5, FLAGS(TConst));
//   n_continue.key = newsym(2977070660, (const u8*)"continue", 8, FLAGS(TContinue));
//   n_default.key = newsym(2470140894, (const u8*)"default", 7, FLAGS(TDefault));
//   n_defer.key = newsym(436337467, (const u8*)"defer", 5, FLAGS(TDefer));
//   n_else.key = newsym(3183434736, (const u8*)"else", 4, FLAGS(TElse));
//   n_enum.key = newsym(2171383808, (const u8*)"enum", 4, FLAGS(TEnum));
//   n_fallthrough.key = newsym(2150923017, (const u8*)"fallthrough", 11, FLAGS(TFallthrough));
//   n_for.key = newsym(2901640080, (const u8*)"for", 3, FLAGS(TFor));
//   n_fun.key = newsym(2832955486, (const u8*)"fun", 3, FLAGS(TFun));
//   n_go.key = newsym(1109423947, (const u8*)"go", 2, FLAGS(TGo));
//   n_if.key = newsym(959999494, (const u8*)"if", 2, FLAGS(TIf));
//   n_import.key = newsym(288002260, (const u8*)"import", 6, FLAGS(TImport));
//   n_in.key = newsym(1094220446, (const u8*)"in", 2, FLAGS(TIn));
//   n_interface.key = newsym(2229948720, (const u8*)"interface", 9, FLAGS(TInterface));
//   n_is.key = newsym(1312329493, (const u8*)"is", 2, FLAGS(TIs));
//   n_return.key = newsym(2246981567, (const u8*)"return", 6, FLAGS(TReturn));
//   n_select.key = newsym(297952813, (const u8*)"select", 6, FLAGS(TSelect));
//   n_struct.key = newsym(2462236192, (const u8*)"struct", 6, FLAGS(TStruct));
//   n_switch.key = newsym(2480955249, (const u8*)"switch", 6, FLAGS(TSwitch));
//   n_symbol.key = newsym(4093333969, (const u8*)"symbol", 6, FLAGS(TSymbol));
//   n_type.key = newsym(1361572173, (const u8*)"type", 4, FLAGS(TType));
//   n_var.key = newsym(2317739966, (const u8*)"var", 3, FLAGS(TVar));
//   n_while.key = newsym(231090382, (const u8*)"while", 5, FLAGS(TWhile));
//   #undef FLAGS
// }

// -----------------------------------------------------------------------------------------

// symhashdata returns an unsigned integer hash of an array of bytes.
// The FNV1a algorithm is fast and has good distribution for common short names.
// This makes is suitable for source text string hashing and is used by Sym.
u32 symhashdata(const u8* buf, size_t len) {
  const u32 prime = 0x01000193; // (16777619)
  u32 hash = 0x811C9DC5; // seed (2166136261)
  const u8* end = buf + len;
  while (buf < end) {
    hash = (*buf++ ^ hash) * prime;
  }
  return hash;
}


// dumpSymTree functionn
#ifdef DEBUG
static Str dumpSymTreeFmtKey(Str s, Sym k) {
  s = sdscatrepr(s, k, sdslen(k));
  return sdscatprintf(s, " (flags %02X, hash %u)", SYM_HDR(k)->sh.flags, SYM_HDR(k)->hash);
}
static void dumpSymTree() {
  auto s = RBRepr(symRoot, sdsempty(), 0, &dumpSymTreeFmtKey);
  s[sdslen(s)] = '\n'; // replace NUL with ln
  fwrite(s, sdslen(s)+1, 1, stderr);
  sdsfree(s);
}
#endif


static Sym newsym(u32 hash, const u8* ptr, size_t len, u8 flags) {
  assert(len <= 0xFFFF);
  auto hp = (SymHeader*)malloc(sizeof(SymHeader) + len + 1);
  hp->hash = hash;
  hp->sh.len = len;
  hp->sh.alloc = len;
  hp->sh.flags = flags;
  auto s = ((u8*)hp) + sizeof(SymHeader); // pointer to data
  memcpy(s, ptr, len);
  s[len] = 0;
  return (Sym)s;
}


// RB functions
inline static RBNode* RBAllocNode() {
  return (RBNode*)malloc(sizeof(RBNode));
}

// syms are never removed from the interning tree
inline static void RBFreeNode(RBNode* node) { assert(!"sym deallocated"); }


inline static int RBCmp(Sym a, Sym b) {
  if (symhash(a) < symhash(b)) {
    return -1;
  }
  if (symhash(a) > symhash(b)) {
    return 1;
  }
  int cmp = (int)symlen(a) - (int)symlen(b);
  if (cmp == 0) {
    // hash is identical and length is identical; compare bytes.
    cmp = memcmp(a, b, symlen(a));
  }
  return cmp;
}


inline static Sym symFind(u32 hash, const u8* aptr, u16 alen) {
  RBNode* node = symRoot;
  while (node) {
    // IMPORTANT: The comparison here MUST match the comparison used for other
    // operations on the tree. I.e. it must match RBCmp.
    // int cmp = RBCmp(key, (RBKEY)node->key);

    Sym b = (RBKEY)node->key;
    if (hash < symhash(b)) {
      node = node->left;
    } else if (hash > symhash(b)) {
      node = node->right;
    } else {
      int cmp = (int)alen - (int)symlen(b);
      if (cmp == 0) {
        cmp = memcmp(aptr, b, alen);
        if (cmp == 0) {
          return b;
        }
      }
      node = cmp < 0 ? node->left : node->right;
    }
  }
  return NULL;
}


Sym symget(const u8* data, size_t _len, u32 hash) {
  assert(_len <= 0xFFFF);
  u16 len = (u16)_len;
  auto s = symFind(hash, data, len);
  if (s == NULL) {
    auto key = newsym(hash, data, len, SDS_TYPE_16);
    bool rbhas = RBHas(symRoot, key);
    s = newsym(hash, data, len, SDS_TYPE_16);
    symRoot = RBInsert(symRoot, s);
  }
  return s;
}


Sym symgeth(const u8* data, size_t len) {
  return symget(data, len, symhashdata(data, len));
}


// ---------------------------------------------------------------------------------------
// sym constant data generator
#if defined(W_SYM_RUN_GENERATOR) && W_SYM_RUN_GENERATOR == 1

inline static Str fmt_nodes(const RBNode* n, Str s) {
  // descent first
  if (n->left) {
    s = fmt_nodes(n->left, s);
  }
  if (n->right) {
    s = fmt_nodes(n->right, s);
  }

  s = sdscat(s, "static RBNode n_");
  s = sdscatsds(s, n->key);
  s = sdscat(s, " = { ");

  // { key, isred, left, right }

  // s = sdscatfmt(s, "sym_%S, ", n->key);
  s = sdscat(s, "null, ");

  s = sdscat(s, n->isred ? "true, " : "false, ");
  if (n->left) {
    s = sdscatfmt(s, "&n_%S, ", n->left->key);
  } else {
    s = sdscat(s, "null, ");
  }
  if (n->right) {
    s = sdscatfmt(s, "&n_%S ", n->right->key);
  } else {
    s = sdscat(s, "null ");
  }
  s = sdscat(s, "};\n");
  return s;
}

static constsds fmtkey(Sym k) { return k; } // Sym is a type of Str :-)

__attribute__((constructor)) static void gen_constants() {
  printf("//-- BEGIN gen_constants() at %s:%d\n\n", __FILE__, __LINE__);

  #define SYM_DEF(str, tok)                                               \
    Sym sym_##str = newsym(symhashdata((const u8*)(#str), strlen(#str)),  \
    (const u8*)(#str), (u32)strlen(#str), SDS_TYPE_16);
  TOKEN_KEYWORDS(SYM_DEF)
  #undef SYM_DEF


  RBNode* root = NULL;
  #define KW(str, tok) root = RBInsert(root, sym_##str);
  TOKEN_KEYWORDS(KW)
  #undef KW

  printf("\n%s\n", fmt_nodes(root, sdsempty()));

  printf("static RBNode* symRoot = &n_%s;\n", root->key);

  // generate a sort of checksum used in debug mode to make sure the generator is updated
  // when keywords change. See the function debug_check() below as well.
  int col = 0;
  printf("#ifndef NDEBUG\nstatic const char* const debugKeywordsCheck =\n  \"");
  #define KW(str, tok) \
    printf("%s %02x ", #str, tok); \
    col += strlen(#str) + 4;       \
    if (col > 70) {                \
      col = 0;                     \
      printf("\"\n  \"");          \
    }
  TOKEN_KEYWORDS(KW)
  #undef KW
  printf("\";\n#endif\n");

  printf("\n// initializer code:\n");
  printf("__attribute__((constructor)) static void init() {\n");

  printf("  #define FLAGS(t) (SDS_TYPE_16 | ((t - TKeywordsStart) << SDS_TYPE_BITS))\n");
  #define SYM_DEF(str, tok) {                                            \
    auto hdr = SYM_HDR(sym_##str); \
    printf(                                                              \
      "  n_" #str ".key = newsym(%u, (const u8*)\"" #str "\", %u, FLAGS(" #tok "));\n", \
      hdr->hash,                                                         \
      hdr->sh.len                                                       \
    ); \
  }
  TOKEN_KEYWORDS(SYM_DEF)
  #undef SYM_DEF
  printf("  #undef FLAGS\n");
  printf("}\n");

  printf("\n//-- END gen_constants() at %s:%d\n\n", __FILE__, __LINE__);
  exit(1);
}

#endif /* W_SYM_RUN_GENERATOR == 1 */

// ---------------------------------------------------------------------------------------
// sym constant data generator 2
#if defined(W_SYM_RUN_GENERATOR) && W_SYM_RUN_GENERATOR == 2

inline static Str fmt_nodes(const RBNode* n, Str s) {
  // descent first
  if (n->left) {
    s = fmt_nodes(n->left, s);
  }
  if (n->right) {
    s = fmt_nodes(n->right, s);
  }

  s = sdscat(s, "static RBNode n_");
  s = sdscatsds(s, n->key);
  s = sdscat(s, " = { ");

  // { key, isred, left, right }

  s = sdscatfmt(s, "sym_%S, ", n->key);
  // s = sdscat(s, "null, ");

  s = sdscat(s, n->isred ? "true, " : "false, ");
  if (n->left) {
    s = sdscatfmt(s, "&n_%S, ", n->left->key);
  } else {
    s = sdscat(s, "null, ");
  }
  if (n->right) {
    s = sdscatfmt(s, "&n_%S ", n->right->key);
  } else {
    s = sdscat(s, "null ");
  }
  s = sdscat(s, "};\n");
  return s;
}

static constsds fmtkey(Sym k) { return k; } // Sym is a type of Str :-)

__attribute__((constructor)) static void gen_constants() {
  printf("//-- BEGIN gen_constants() at %s:%d\n\n", __FILE__, __LINE__);

  #define SYM_DEF(str, tok)                                               \
    Sym sym_##str = newsym(symhashdata((const u8*)(#str), strlen(#str)),  \
    (const u8*)(#str), (u32)strlen(#str), SDS_TYPE_16);
  TOKEN_KEYWORDS(SYM_DEF)
  #undef SYM_DEF

  #define SYM_DEF(name)                                                     \
    Sym sym_##name = newsym(symhashdata((const u8*)(#name), strlen(#name)), \
    (const u8*)(#name), (u32)strlen(#name), SDS_TYPE_16);
  PREDEFINED_IDENTS(SYM_DEF)
  #undef SYM_DEF


  #define SYM_DEF(str, name, flags)  {                                  \
    auto hdr = SYM_HDR(sym_##name);                                     \
    auto hash = (u8*)&hdr->hash;                                        \
    auto len = (u8*)&hdr->sh.len;                                       \
    printf(                                                             \
      "const Sym sym_" #name " = \""                                    \
      /* padding = align2(sizeof(SymHeader), 8) - sizeof(SymHeader) */  \
      "\\0\\0\\0\\0\\0\\0\\0"                                           \
      "\\x%02X\\x%02X\\x%02X\\x%02X" /* SymHeader.hash */               \
      "\\x%02X\\x%02X"               /* sdshdr16.len */                 \
      "\\x%02X\\x%02X"               /* sdshdr16.alloc */               \
      "\\x%02X"                      /* sdshdr16.flags = SDS_TYPE_16 */ \
      "\"\"" str                     /* "" is here to terminate \x03 */ \
      "\" + %d;\n",                                                     \
      hash[0], hash[1], hash[2], hash[3],                               \
      len[0],  len[1],                                                  \
      len[0],  len[1],                                                  \
      SDS_TYPE_16 | ((flags) << SDS_TYPE_BITS),                         \
      16 /* align2(sizeof(SymHeader), 8) */                             \
    );                                                                  \
  }
  #define SYM_DEF_KW(str, tok) SYM_DEF(#str, str, (tok - TKeywordsStart))
  #define SYM_DEF_IDENT(name)  SYM_DEF(#name, name, 0)
  TOKEN_KEYWORDS(SYM_DEF_KW)
  PREDEFINED_IDENTS(SYM_DEF_IDENT)
  #undef SYM_DEF



  RBNode* root = NULL;
  #define KW(str, tok) root = RBInsert(root, sym_##str);
  TOKEN_KEYWORDS(KW)
  #undef KW
  #define KW(name) root = RBInsert(root, sym_##name);
  PREDEFINED_IDENTS(KW)
  #undef KW

  printf("\n%s\n", fmt_nodes(root, sdsempty()));

  printf("static RBNode* symRoot = &n_%s;\n", root->key);

  // generate a sort of checksum used in debug mode to make sure the generator is updated
  // when keywords change. See the function debug_check() below as well.
  int col = 0;
  printf("#ifndef NDEBUG\nstatic const char* const debugKeywordsCheck =\n  \"");
  #define KW(str, tok)             \
    printf("%s %02x ", #str, tok); \
    col += strlen(#str) + 4;       \
    if (col > 70) {                \
      col = 0;                     \
      printf("\"\n  \"");          \
    }
  TOKEN_KEYWORDS(KW)
  #undef KW
  printf("\";\n#endif\n");




  // static u32 lens[] = {
  //   #define SYM_DEF(str, tok) strlen(#str),
  //   TOKEN_KEYWORDS(SYM_DEF)
  //   #undef SYM_DEF
  // };
  // u32 minlen = 999999;
  // u32 maxlen = 0;
  // for (u32 i = 0; i < sizeof(lens)/sizeof(u32); i++) {
  //   u32 len = lens[i];
  //   if (len < minlen) { minlen = len; }
  //   if (len > maxlen) { maxlen = len; }
  // }
  // u32* lenmap = calloc(1, sizeof(u32) * (maxlen - minlen));
  // for (u32 i = 0; i < sizeof(lens)/sizeof(u32); i++) {
  //   u32 len = lens[i];
  //   u32 index = len - minlen;
  //   if (lenmap[index] == 0) {
  //     lenmap[index] = 1;
  //     printf(
  //       "typedef struct {"
  //       " u32 h;"
  //       " uint16_t l;"
  //       " uint16_t a;"
  //       " unsigned char f;"
  //       " char b[%u];"
  //       "} constSym%u;\n",
  //       len, len
  //     );
  //   }
  // }


  // u8 flags = SDS_TYPE_16 | ((T_IF - TKeywordsStart) << SDS_TYPE_BITS);
  // printf("SDS_TYPE_16 = %02X, SYM_FLAGS_MASK_KEYWORD = %02X, kw_index = %02X\n",
  //   flags & SDS_TYPE_16,
  //   flags >> SDS_TYPE_BITS,
  //   T_IF - TKeywordsStart
  // );

  // printf("SDS_TYPE_16 = %02X, SYM_KEYWORD_FLAG = %02X, | = %02X, A = %02X, B = %02X\n",
  //   SDS_TYPE_16, SYM_KEYWORD_FLAG,
  //   SDS_TYPE_16 | SYM_KEYWORD_FLAG,
  //   (SDS_TYPE_16 | SYM_KEYWORD_FLAG) & SDS_TYPE_16,
  //   (SDS_TYPE_16 | SYM_KEYWORD_FLAG) & SYM_KEYWORD_FLAG);

  // printf("%s\n", RBRepr(root, sdsempty(), 0, &fmtkey));

  // auto root2 = RBInsert(root, sym_case);
  // printf("root1 = %p, root2 = %p\n", root, root2);
  // printf("%s\n", RBRepr(root, sdsempty(), 0, &fmtkey));

  // u32 hash = hashFNV1a((const u8*)("cont"), strlen("cont"));
  // auto s = newsym(hash, (const u8*)"cont", strlen("cont"));
  // root = RBInsert(root, s);

  // printf("%s\n", RBRepr(root, sdsempty(), 0, &fmtkey));

  printf("\n//-- END gen_constants() at %s:%d\n\n", __FILE__, __LINE__);
  exit(1);
}

#endif /* W_SYM_RUN_GENERATOR == 2 */


// -----------------------------------------------------------------------------------------------


#if !defined(NDEBUG) && !defined(W_SYM_RUN_GENERATOR)
__attribute__((constructor)) static void debug_check() {
  auto s = sdsempty();
  #define KW(str, tok) s = sdscatprintf(s, "%s %02x ", #str, tok);
  TOKEN_KEYWORDS(KW)
  #undef KW
  if (strcmp(debugKeywordsCheck, s) != 0) {
    printf("Keywords changed.\n");
    printf("Define W_SYM_RUN_GENERATOR in %s to run code generator.\n", __FILE__);
    exit(1);
  }
}
#endif


// -----------------------------------------------------------------------------------------------


typedef struct {
  Sym   key;
  void* value;
} mapEntry;

static const u32 mapBucketSize = 8; // entries in a bucket

struct SymMapBucket {
  mapEntry entries[mapBucketSize];
};

void SymMapInit(SymMap* m, u32 initbuckets) {
  m->cap = initbuckets;
  m->len = 0;
  m->buckets = (struct SymMapBucket*)calloc(m->cap, sizeof(struct SymMapBucket));
}

void SymMapFree(SymMap* m) {
  free(m->buckets);
  #if DEBUG
  m->buckets = NULL;
  m->len = 0;
  m->cap = 0;
  #endif
}

static void mapGrow(SymMap* m) {
  u32 cap = m->cap * 2;
  rehash: {
    auto buckets = (struct SymMapBucket*)calloc(cap, sizeof(struct SymMapBucket));
    for (u32 bi = 0; bi < m->cap; bi++) {
      auto b = &m->buckets[bi];
      for (u32 i = 0; i < mapBucketSize; i++) {
        auto e = &b->entries[i];
        if (e->key == NULL) {
          break;
        }
        // TODO: compact deleted entries. If e->value==NULL then the entry is unused.
        u32 index = symhash(e->key) % cap;
        auto b2 = &buckets[index];
        bool fit = false;
        for (u32 i2 = 0; i2 < mapBucketSize; i2++) {
          auto e2 = &b2->entries[i2];
          if (e2->key == NULL) {
            *e2 = *e;
            fit = true;
            break;
          }
        }
        if (!fit) {
          free(buckets);
          cap = cap * 2;
          goto rehash;
        }
      }
    }
    free(m->buckets);
    m->buckets = buckets;
    m->cap = cap;
  }
}


// SymMapSet inserts key=value into m.
// Returns replaced value or NULL if key did not exist in map.
void* SymMapSet(SymMap* m, Sym key, void* value) {
  assert(value != NULL);
  while (1) { // grow loop
    u32 index = symhash(key) % m->cap;
    auto b = &m->buckets[index];
    // dlog("bucket(key=\"%s\") #%u  b=%p e=%p", key, index, b, &b->entries[0]);
    for (u32 i = 0; i < mapBucketSize; i++) {
      auto e = &b->entries[i];
      if (e->value == NULL) {
        // free slot
        e->key = key;
        e->value = value;
        m->len++;
        return NULL;
      }
      if (e->key == key) {
        // key already in map -- replace value
        auto oldval = e->value;
        e->value = value;
        return oldval;
      }
      // dlog("collision key=\"%s\" <> e->key=\"%s\"", key, e->key);
    }
    // overloaded -- grow buckets
    // dlog("grow & rehash");
    mapGrow(m);
  }
}


void* SymMapDel(SymMap* m, Sym key) {
  u32 index = symhash(key) % m->cap;
  auto b = &m->buckets[index];
  for (u32 i = 0; i < mapBucketSize; i++) {
    auto e = &b->entries[i];
    if (e->key == key) {
      if (!e->value) {
        break;
      }
      // mark as deleted
      auto value = e->value;
      e->value = NULL;
      m->len--;
      return value;
    }
  }
  return NULL;
}


void* SymMapGet(const SymMap* m, Sym key) {
  u32 index = symhash(key) % m->cap;
  auto b = &m->buckets[index];
  for (u32 i = 0; i < mapBucketSize; i++) {
    auto e = &b->entries[i];
    if (e->key == key) {
      return e->value;
    }
    if (e->key == NULL) {
      break;
    }
  }
  return NULL;
}


void SymMapClear(SymMap* m) {
  memset(m->buckets, 0, sizeof(struct SymMapBucket) * m->cap);
  m->len = 0;
}


void SymMapIter(const SymMap* m, SymMapIterator* it, void* userdata) {
  bool stop = false;
  for (u32 bi = 0; bi < m->cap; bi++) {
    auto b = &m->buckets[bi];
    for (u32 i = 0; i < mapBucketSize; i++) {
      auto e = &b->entries[i];
      if (e->key == NULL) {
        break;
      }
      if (e->value != NULL) {
        it(e->key, e->value, &stop, userdata);
        if (stop) {
          return;
        }
      }
    }
  }
}


#if 0
static void testMapIterator(Sym key, void* value, bool* stop, void* userdata) {
  // dlog("\"%s\" => %zu", key, (size_t)value);
  size_t* n = (size_t*)userdata;
  (*n)++;
}
__attribute__((constructor)) static void test_SymMap() {
  SymMap m;
  SymMapInit(&m, 64);

  assert(m.len == 0);

  #define SYM(cstr) symgeth((const u8*)(cstr), strlen(cstr))
  void* oldval;

  oldval = SymMapSet(&m, SYM("hello"), (void*)1);
  dlog("SymMapSet(hello) => %zu", (size_t)oldval);
  assert(m.len == 1);

  oldval = SymMapSet(&m, SYM("hello"), (void*)2);
  dlog("SymMapSet(hello) => %zu", (size_t)oldval);
  assert(m.len == 1);

  assert(SymMapDel(&m, SYM("hello")) == (void*)2);
  assert(m.len == 0);

  size_t n = 100;
  SymMapSet(&m, SYM("break"),       (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("case"),        (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("const"),       (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("continue"),    (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("default"),     (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("defer"),       (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("else"),        (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("enum"),        (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("fallthrough"), (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("for"),         (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("fun"),         (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("go"),          (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("if"),          (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("import"),      (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("in"),          (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("interface"),   (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("is"),          (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("return"),      (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("select"),      (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("struct"),      (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("switch"),      (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("symbol"),      (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("type"),        (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("var"),         (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("while"),       (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("_"),           (void*)n++); assert(m.len == n - 100);
  SymMapSet(&m, SYM("int"),         (void*)n++); assert(m.len == n - 100);

  n = 0;
  SymMapIter(&m, testMapIterator, &n);
  assert(n == 27);

  n = 100;
  assert(SymMapGet(&m, SYM("break"))       == (void*)n++);
  assert(SymMapGet(&m, SYM("case"))        == (void*)n++);
  assert(SymMapGet(&m, SYM("const"))       == (void*)n++);
  assert(SymMapGet(&m, SYM("continue"))    == (void*)n++);
  assert(SymMapGet(&m, SYM("default"))     == (void*)n++);
  assert(SymMapGet(&m, SYM("defer"))       == (void*)n++);
  assert(SymMapGet(&m, SYM("else"))        == (void*)n++);
  assert(SymMapGet(&m, SYM("enum"))        == (void*)n++);
  assert(SymMapGet(&m, SYM("fallthrough")) == (void*)n++);
  assert(SymMapGet(&m, SYM("for"))         == (void*)n++);
  assert(SymMapGet(&m, SYM("fun"))         == (void*)n++);
  assert(SymMapGet(&m, SYM("go"))          == (void*)n++);
  assert(SymMapGet(&m, SYM("if"))          == (void*)n++);
  assert(SymMapGet(&m, SYM("import"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("in"))          == (void*)n++);
  assert(SymMapGet(&m, SYM("interface"))   == (void*)n++);
  assert(SymMapGet(&m, SYM("is"))          == (void*)n++);
  assert(SymMapGet(&m, SYM("return"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("select"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("struct"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("switch"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("symbol"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("type"))        == (void*)n++);
  assert(SymMapGet(&m, SYM("var"))         == (void*)n++);
  assert(SymMapGet(&m, SYM("while"))       == (void*)n++);
  assert(SymMapGet(&m, SYM("_"))           == (void*)n++);
  assert(SymMapGet(&m, SYM("int"))         == (void*)n++);

  n = 200;
  SymMapSet(&m, SYM("xbreak"),       (void*)n++);
  SymMapSet(&m, SYM("xcase"),        (void*)n++);
  SymMapSet(&m, SYM("xconst"),       (void*)n++);
  SymMapSet(&m, SYM("xcontinue"),    (void*)n++);
  SymMapSet(&m, SYM("xdefault"),     (void*)n++);
  SymMapSet(&m, SYM("xdefer"),       (void*)n++);
  SymMapSet(&m, SYM("xelse"),        (void*)n++);
  SymMapSet(&m, SYM("xenum"),        (void*)n++);
  SymMapSet(&m, SYM("xfallthrough"), (void*)n++);
  SymMapSet(&m, SYM("xfor"),         (void*)n++);
  SymMapSet(&m, SYM("xfun"),         (void*)n++);
  SymMapSet(&m, SYM("xgo"),          (void*)n++);
  SymMapSet(&m, SYM("xif"),          (void*)n++);
  SymMapSet(&m, SYM("ximport"),      (void*)n++);
  SymMapSet(&m, SYM("xin"),          (void*)n++);
  SymMapSet(&m, SYM("xinterface"),   (void*)n++);
  SymMapSet(&m, SYM("xis"),          (void*)n++);
  SymMapSet(&m, SYM("xreturn"),      (void*)n++);
  SymMapSet(&m, SYM("xselect"),      (void*)n++);
  SymMapSet(&m, SYM("xstruct"),      (void*)n++);
  SymMapSet(&m, SYM("xswitch"),      (void*)n++);
  SymMapSet(&m, SYM("xsymbol"),      (void*)n++);
  SymMapSet(&m, SYM("xtype"),        (void*)n++);
  SymMapSet(&m, SYM("xvar"),         (void*)n++);
  SymMapSet(&m, SYM("xwhile"),       (void*)n++);
  SymMapSet(&m, SYM("x_"),           (void*)n++);
  SymMapSet(&m, SYM("xint"),         (void*)n++);

  n = 200;
  assert(SymMapGet(&m, SYM("xbreak"))       == (void*)n++);
  assert(SymMapGet(&m, SYM("xcase"))        == (void*)n++);
  assert(SymMapGet(&m, SYM("xconst"))       == (void*)n++);
  assert(SymMapGet(&m, SYM("xcontinue"))    == (void*)n++);
  assert(SymMapGet(&m, SYM("xdefault"))     == (void*)n++);
  assert(SymMapGet(&m, SYM("xdefer"))       == (void*)n++);
  assert(SymMapGet(&m, SYM("xelse"))        == (void*)n++);
  assert(SymMapGet(&m, SYM("xenum"))        == (void*)n++);
  assert(SymMapGet(&m, SYM("xfallthrough")) == (void*)n++);
  assert(SymMapGet(&m, SYM("xfor"))         == (void*)n++);
  assert(SymMapGet(&m, SYM("xfun"))         == (void*)n++);
  assert(SymMapGet(&m, SYM("xgo"))          == (void*)n++);
  assert(SymMapGet(&m, SYM("xif"))          == (void*)n++);
  assert(SymMapGet(&m, SYM("ximport"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("xin"))          == (void*)n++);
  assert(SymMapGet(&m, SYM("xinterface"))   == (void*)n++);
  assert(SymMapGet(&m, SYM("xis"))          == (void*)n++);
  assert(SymMapGet(&m, SYM("xreturn"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("xselect"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("xstruct"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("xswitch"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("xsymbol"))      == (void*)n++);
  assert(SymMapGet(&m, SYM("xtype"))        == (void*)n++);
  assert(SymMapGet(&m, SYM("xvar"))         == (void*)n++);
  assert(SymMapGet(&m, SYM("xwhile"))       == (void*)n++);
  assert(SymMapGet(&m, SYM("x_"))           == (void*)n++);
  assert(SymMapGet(&m, SYM("xint"))         == (void*)n++);

  // del
  assert(SymMapSet(&m, SYM("hello"), (void*)2) == NULL);
  assert(SymMapGet(&m, SYM("hello")) == (void*)2);
  assert(SymMapDel(&m, SYM("hello")) == (void*)2);
  assert(SymMapGet(&m, SYM("hello")) == NULL);
  assert(SymMapSet(&m, SYM("hello"), (void*)2) == NULL);
  assert(SymMapGet(&m, SYM("hello")) == (void*)2);

  n = 100;
  assert(SymMapDel(&m, SYM("break"))       == (void*)n++);
  assert(SymMapDel(&m, SYM("case"))        == (void*)n++);
  assert(SymMapDel(&m, SYM("const"))       == (void*)n++);
  assert(SymMapDel(&m, SYM("continue"))    == (void*)n++);
  assert(SymMapDel(&m, SYM("default"))     == (void*)n++);
  assert(SymMapDel(&m, SYM("defer"))       == (void*)n++);
  assert(SymMapDel(&m, SYM("else"))        == (void*)n++);
  assert(SymMapDel(&m, SYM("enum"))        == (void*)n++);
  assert(SymMapDel(&m, SYM("fallthrough")) == (void*)n++);
  assert(SymMapDel(&m, SYM("for"))         == (void*)n++);
  assert(SymMapDel(&m, SYM("fun"))         == (void*)n++);
  assert(SymMapDel(&m, SYM("go"))          == (void*)n++);
  assert(SymMapDel(&m, SYM("if"))          == (void*)n++);
  assert(SymMapDel(&m, SYM("import"))      == (void*)n++);
  assert(SymMapDel(&m, SYM("in"))          == (void*)n++);
  assert(SymMapDel(&m, SYM("interface"))   == (void*)n++);
  assert(SymMapDel(&m, SYM("is"))          == (void*)n++);
  assert(SymMapDel(&m, SYM("return"))      == (void*)n++);
  assert(SymMapDel(&m, SYM("select"))      == (void*)n++);
  assert(SymMapDel(&m, SYM("struct"))      == (void*)n++);
  assert(SymMapDel(&m, SYM("switch"))      == (void*)n++);
  assert(SymMapDel(&m, SYM("symbol"))      == (void*)n++);
  assert(SymMapDel(&m, SYM("type"))        == (void*)n++);
  assert(SymMapDel(&m, SYM("var"))         == (void*)n++);
  assert(SymMapDel(&m, SYM("while"))       == (void*)n++);
  assert(SymMapDel(&m, SYM("_"))           == (void*)n++);
  assert(SymMapDel(&m, SYM("int"))         == (void*)n++);

  assert(SymMapGet(&m, SYM("break"))       == 0);
  assert(SymMapGet(&m, SYM("case"))        == 0);
  assert(SymMapGet(&m, SYM("const"))       == 0);
  assert(SymMapGet(&m, SYM("continue"))    == 0);
  assert(SymMapGet(&m, SYM("default"))     == 0);
  assert(SymMapGet(&m, SYM("defer"))       == 0);
  assert(SymMapGet(&m, SYM("else"))        == 0);
  assert(SymMapGet(&m, SYM("enum"))        == 0);
  assert(SymMapGet(&m, SYM("fallthrough")) == 0);
  assert(SymMapGet(&m, SYM("for"))         == 0);
  assert(SymMapGet(&m, SYM("fun"))         == 0);
  assert(SymMapGet(&m, SYM("go"))          == 0);
  assert(SymMapGet(&m, SYM("if"))          == 0);
  assert(SymMapGet(&m, SYM("import"))      == 0);
  assert(SymMapGet(&m, SYM("in"))          == 0);
  assert(SymMapGet(&m, SYM("interface"))   == 0);
  assert(SymMapGet(&m, SYM("is"))          == 0);
  assert(SymMapGet(&m, SYM("return"))      == 0);
  assert(SymMapGet(&m, SYM("select"))      == 0);
  assert(SymMapGet(&m, SYM("struct"))      == 0);
  assert(SymMapGet(&m, SYM("switch"))      == 0);
  assert(SymMapGet(&m, SYM("symbol"))      == 0);
  assert(SymMapGet(&m, SYM("type"))        == 0);
  assert(SymMapGet(&m, SYM("var"))         == 0);
  assert(SymMapGet(&m, SYM("while"))       == 0);
  assert(SymMapGet(&m, SYM("_"))           == 0);
  assert(SymMapGet(&m, SYM("int"))         == 0);

  SymMapFree(&m);
}
#endif


// -----------------------------------------------------------------------------------------------

